---
title: "w241: Experiments and Causality"
subtitle: "Blocking and Clustering"
author: "David Reiley, David Broockman, D. Alex Hughes"
institute: "UC Berkeley, School of Information"
date: "Updated: `r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts] 
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, echo=FALSE, message=FALSE, include=FALSE}
library(tidyverse)
library(ggplot2)
library(patchwork)
library(data.table)

library(lmtest)
library(sandwich)

options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(echo = TRUE, dpi = 300)


theme_set(theme_minimal())
```

# Blocking

- Hard to know if it was due to chance when there are large differences between treatment and control.
- Need to reduce the size of the differences that can arise by chance.
- Increase statistical power given an experiment with same sample and effect size.
- If some variables are related to the outcome, restrict ourselves to randomizations that keep treatment and control similar.

---

# Make Data

```{r define functions, echo = FALSE} 
make_data <- function(effect_size=0) {
  group <- c(rep("Man",20),rep("Woman",20))

  po_control <- c(
    seq(from = 1, to = 20), 
    seq(from = 51, to = 70)
    )

  ## Suppose there is no effect. 
  ## Then, the potential outcomes to control are equal 
  ## to the potential outcomes to treatment. 

  po_treatment <- po_control + effect_size

  d <- data.table(
    'Control'   = po_control,
    'Treatment' = po_treatment, 
    'group'     = group
  )
}

randomize <- function(size=40) { 
  ## an (unnecessary) function to randomize units into 
  ## treatment and control 
  ## ---
  ## args: 
  ##  - units_per_group: how many zero and one should be returned
  
  assignment_vector <- rep(c('Control', 'Treatment'), each = size / 2)
  sample(assignment_vector)
} 
```

```{r}
d <- make_data(effect_size=0)
head(d)
```

---
# Randomization

```{r}
d[ , assignment := randomize(size=40)][ , 
  table('Sex' = group, 'Assignment' = assignment)]

d[ , assignment := randomize(size=40)][ , 
  table('Sex' = group, 'Assignment' = assignment)]
```

---
# Block Randomization

```{r} 
block_randomize <- function(size) { 
  ## this function will be executed /within/ the  data.table that 
  ## holds the data. It could be run outside, but the assignment 
  ## in place that data.table provides make it clean inside.
  conditions <- c('Control', 'Treatment')
  
  if(size %% 2 == 0) { 
    ## if there are an even number of units in each block this is easy
    urn <- rep(conditions, times = size/2)  
  } else if(size %% 2 == 1) { 
    ## if there are an odd number, then produce conditions to the 
    ## nearest even number that is less than the number of units 
    ## then add one more assignment condition, sampled at random
    urn <- c(rep(conditions, times = (size/2) - 0.5), sample(conditions, size = 1))
  } 
  
  ## now, shuffle it up return the shuffled sequence
  assignment <- sample(urn)
  return(assignment)
}
```

---
# Randomization

```{r run randomize}
d[ , block_assignment := block_randomize(size=.N), by = group][ , 
  table('Sex' = group, 'Assignment' = block_assignment)]

d[ , block_assignment := block_randomize(size=.N), by = group][ , 
  table('Sex' = group, 'Assignment' = block_assignment)]
```

---
# Conduct Experiment 

```{r}
conduct_experiment <- function(potential_control, potential_treatment, assignment) { 
  outcomes <- potential_treatment * I(assignment == "Treatment") + 
    potential_control * I(assignment == "Control")
  
  return(outcomes)
}

d[ , Y := conduct_experiment(Control, Treatment, block_assignment)]

head(d)
```

---
# Estimate ATE

```{r}
estimate_ate <- function(y_values, treatment, verbose=FALSE) { 
  
  treatment_group_mean <- mean(y_values[treatment == 'Treatment'])
  control_group_mean   <- mean(y_values[treatment == 'Control'])
  
  ate <- treatment_group_mean - control_group_mean
  
  if(verbose) {
    return(
      list(
        "tg_mean" = treatment_group_mean, 
        "cg_mean" = control_group_mean, 
        "ate" = ate))
    } else { 
      return("ate" = ate)
      }
}

ate <- d[ , estimate_ate(y_values = Y, treatment = block_assignment, verbose=TRUE)]
ate
```

---
# Simulate A Normal Study

```{r}
simulate_normal_study <- function(effect_size) { 
  ## create world 
  d <- make_data(effect_size=effect_size)

  ## randomly assign and count the number of women in treatment 
  d[ , assignment := randomize()]
  
  women_in_treatment <- d[group == 'Woman' & assignment == 'Treatment', .N]
  
  ## measure outcomes 
  d[ , Y := conduct_experiment(Control, Treatment, assignment)]
  
  ## estimate ate 
  ate <- d[ , estimate_ate(y_values = Y, treatment = assignment)]
  
  ## return objects 
  ##  - `ate` from the `estimate_ate` function.
  ##  - `women_in_treatment` as a count
  return(list('ate' = ate, 'women_in_treatment' = women_in_treatment))
}
```

---
# Run One Normal Study

```{r run a single normal study]}
normal_study <- simulate_normal_study(effect_size = 0)
normal_study
```

---
# Simulate Many Normal Studies 

```{r}
many_normal_studies <- replicate(
  n = 1000, 
  expr = simulate_normal_study(effect_size = 0))

many_normal_studies <- t(many_normal_studies)
head(many_normal_studies)
```

```{r make normal study plots, echo = FALSE} 
normal_ate_density <- ggplot() + 
  aes(x = unlist(many_normal_studies[,1])) + 
  geom_density(fill = '#003262', alpha = 0.7) + 
  scale_x_continuous(limits = c(-30, 30)) + 
  geom_vline(xintercept = 10, color = 'darkorange') + 
  labs(
    title = 'Zero Effect, Simple Randomization', 
    subtitle = 'Some extreme effects',
    x = 'Estimated ATE', 
    y = 'Density'
  )

normal_ate_by_women <- ggplot() + 
  aes(x = unlist(many_normal_studies[,1]), y = unlist(many_normal_studies[,2])) + 
  geom_jitter() + 
  geom_vline(xintercept = 10, color = 'darkorange') + 
  scale_x_continuous(limits = c(-30, 30)) + 
  scale_y_continuous(limits = c(4, 16)) + 
  labs(
    title = 'Treatment Effect vs. Women in Treatment', 
    subtitle = 'Linear, increasing relationship', 
    x = 'Estimated ATE', 
    y = 'Women in Treatment'
  )
```

---
# Plot Normal ATE 

```{r, message = FALSE, echo = FALSE, dev='svglite', fig.height=4, fig.align='center'}
normal_ate_density | normal_ate_by_women 
```

--- 

class: inverse, center, middle

# Benefits of Blocking

---
# Simulate a Block Randomized Study 

```{r}
simulate_blocked_study <- function(effect_size) { 
  ## create world 
  d <- make_data(effect_size=effect_size)
  
  ## randomly assign and count the number of women in treatment 
  d[ , assignment := block_randomize(20), by = group]

  women_in_treatment <- d[group == 'Woman' & assignment == 'Treatment', .N]
  
  ## measure outcomes 
  d[ , Y := conduct_experiment(Control, Treatment, assignment)]
  
  ## estimate ate 
  ate <- d[ , estimate_ate(y_values = Y, treatment = assignment)]
  
  ## return objects 
  ##  - `ate` from the `estimate_ate` function.
  ##  - `women_in_treatment` as a count 
  return(list('ate' = ate, 'women_in_treatment' = women_in_treatment))
}
```

---
# Simulate a Block Randomized Study 
```{r}
blocked_study <- simulate_blocked_study(effect_size = 0)
blocked_study
```

---
# Simulate Many Block Randomized Studies 

```{r}
many_blocked_studies <- replicate(
  n = 1000, 
  expr = simulate_blocked_study(effect_size = 0)
)

many_blocked_studies <- t(many_blocked_studies)
head(many_blocked_studies)
```

```{r, echo = FALSE}
blocked_ate_density <- ggplot() + 
  aes(x = unlist(many_blocked_studies[,1])) + 
  geom_density(fill = 'darkred', alpha = 0.7) + 
  geom_vline(xintercept = 10, color = 'darkorange') + 
  scale_x_continuous(limits = c(-30, 30)) + 
  labs(
    title = 'Zero Effect, Blocked Randomization', 
    subtitle = 'Results tightly centered at true treatment effect',
    x = 'Estimated ATE', y = 'Density'
  )

blocked_ate_by_women <- ggplot() + 
  aes(x = unlist(many_blocked_studies[,1]), y = unlist(many_blocked_studies[,2])) + 
  geom_jitter() + 
  geom_vline(xintercept = 10, color = 'darkorange') + 
  scale_x_continuous(limits = c(-30, 30)) + 
  scale_y_continuous(limits = c(4, 16)) + 
  labs(
    title = 'Treatment Effect vs. Women in Treatment', 
    subtitle = '', 
    x = 'Estimated ATE', 
    y = 'Women in Treatment'
  )
```

---
# Plot Blocked and Unblocked ATE

```{r, message = FALSE, echo = FALSE, dev='svglite', fig.height=4, fig.align='center'}
(normal_ate_density | normal_ate_by_women) /
(blocked_ate_density | blocked_ate_by_women)
```

---
# Plot Unblocked and Blocked

```{r, message = FALSE, echo = FALSE, dev='svglite', fig.height=4, fig.align='center'}
(normal_ate_density | normal_ate_by_women) / 
  (blocked_ate_density | blocked_ate_by_women) 
```

---

# P-values of Blocked vs. Normal Study 

- Blocking allows for more precision (efficiency) by not conducting randomizations where covaraites (e.g. sex) are very imbalanced

```{r}
# Normal Study
mean(abs(many_normal_studies[,1] > 10))
```

```{r}
mean(abs(many_blocked_studies[,1] > 10))
```

---

# Preview: Regression 

```{r}
d <- make_data(effect_size = 10)
d[ , assignment := randomize()]
d[ , Y := conduct_experiment(Control, Treatment, assignment)]

model_simple <- d[ , lm(Y ~ assignment)]
model_mf     <- d[ , lm(Y ~ assignment + group)]
```

---

# Preview: Regression, Cont'd 

```{r, echo = FALSE, message = FALSE, warning = FALSE}
## assuming classical standard errors are appropriate (for ease of presentation)
stargazer::stargazer(
  model_simple, model_mf, 
  type = 'text', 
  omit.stat = c('ser', 'F'), 
  report = 'vcsp*', 
  ci = TRUE, 
  covariate.labels = c('Assigned Treatment', 'Group: Woman', 'Intercept'), 
  column.labels = c('Unblocked', 'Blocked')
)
```

---

# Summary of Blocking

## Blocking

- Reduces the probability that a large Treatment vs. Control difference can occur by change by balancing the presence of similar units across Treatment and Control
- Can dramatically reduce the **standard error** of the estimator (i.e. the standard deviation of the sampling distribution)
- Is successful if the blocks predict the outcome
- Is unsuccessful if the blocks do **not** predict the outcome

## Power 
- Is affected by (a) sample size; and, (b) ratio of treatment effect to uncertainty about the estimate of treatment effect
- The standard deviation of the outcome is often much smaller within groups that are measurable before conducting the experiment

---

class: inverse, center, middle

# Clustering 

---

# Overview of Clustering 

## Clustering

- Often, units can be observed individually, but must be assigned to the same condition
- If there is covariance between group membership and outcomes (often there is) then this experiment does not do *as good a job* at breaking the relationship between treatment assignment and potential outcomes
- Alternatively, you might think of this experiment as producing less *information* about the treatment effect relative to the background noise of the world

---

# Examples of Clustering 

## School Length
- Cannot randomly assign *at the student level* the length of the school day
- Instead, every student at the same school (or district, or state) has to receive the same length

## Broadcast TV Advertisements 
- In broadcast TV, it is not possible to assign advertisements (e.g. for [Babbitt's Sports](https://youtu.be/uguewe3uvo4) to specific individuals
- Instead, whole markets receive the same ads

## Retail Stores and Prices 
- [Retail stores](https://frontierruckus.bandcamp.com/album/deadmalls-and-nightfalls-2) cannot individually assign price discounts to shoppers
- However, prices can be manipulated at the store-level and purchases observed at the individual-level

---

# Reading Assignment 

- Please read *Field Experiments* pages 80-85. 

---

class: inverse, center, middle 

# Clustering Example 

---

# Setting up Data 

## Cluster: The level or unit where treatment is assigned 
- Notice that outcomes can be observed at more fine-grained levels
- There may be difference in *cluster-average* outcomes: 
  - A teacher stubs their toe on the way to school 
  - It is hot or cold in one classroom


```{r}
classrooms_number <- 8
students_number   <- 16 # this is MIDS, not kindergarden

classroom_ids_vector <- rep(x = 1:8, each = 16)
classroom_ids_vector
```

---

# Classroom Example 

```{r}
classroom_noise_vector <- 1:8 + rnorm(n=8, mean=0, sd=.5)
```

```{r make the data table}
d <- data.table(
  student_id      = 1:(8*16), 
  classroom_id    = classroom_ids, 
  classroom_noise = rep(classroom_noise_vector, each = students_number)
)

setkey(d, 'classroom_id')

d[ , student_outcomes_control := rnorm(n=.N, mean=10) + classroom_noise]
d[ , student_outcomes_treat   := student_outcomes_control + rnorm(n=.N, mean=0.75)]
```

---

# Classroom Example, cont'd 

```{r cluster assignment}
urn <- rep(c('Control', 'Treatment'), each = classrooms_number/2)

cluster_assignment_table <- data.table(
  classroom_id         = d[ , unique(classroom_id)],
  classroom_assignment = sample(urn),
  key = 'classroom_id'
)

d[cluster_assignment_table, on=.(classroom_id)]

d

```


```{r}
block_randomize <- function(size) { 
  ## this function will be executed /within/ the  data.table that 
  ## holds the data. It could be run outside, but the assignment 
  ## in place that data.table provides make it clean inside.
  conditions <- c('Control', 'Treatment')
  
  if(size %% 2 == 0) { 
    ## if there are an even number of units in each block this is easy
    urn <- rep(conditions, times = size/2)  
  } else if(size %% 2 == 1) { 
    ## if there are an odd number, then produce conditions to the 
    ## nearest even number that is less than the number of units 
    ## then add one more assignment condition, sampled at random
    urn <- c(rep(conditions, times = (size/2) - 0.5), sample(conditions, size = 1))
  } 
  
  ## now, shuffle it up return the shuffled sequence
  assignment <- sample(urn)
  return(assignment)
}
```

